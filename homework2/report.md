# 41343108

作業一

## 解題說明

實作整個Polynomial類別(ADT)

### 解題策略

1.建構子
  Add( )
  Mult( )
  Eval( )

2.管理Term陣列( termArray / capacity / terms )

## 程式實作

以下為主要程式碼: (瘋狂程設)

```cpp

class Polynomial {
private:
	Term* termArray;
	int capacity;
	int terms;
public:
	Polynomial() :capacity(2), terms(0) {
		termArray = new Term[capacity];
	}
	~Polynomial() { delete[] termArray; }

	Polynomial Add(Polynomial b);

	Polynomial Mult(Polynomial b);

	float Eval(float x);

```

## 效能分析

| 函式       | 時間複雜度    | 空間複雜度         | 原因        |
| -------- | -------- | ------------- | --------- |
| `Add()`  | O(m + n) | O(m + n)      | 每項處理一次    |
| `Mult()` | O(m × n) | O(m + n)（或更多） | 每項相乘一次    |
| `Eval()` | O(m)     | O(1)          | 每項代入 x 計算 |


## 測試與驗證

### 測試案例

| m | n | 結果 A(m,n) |
| - | - | --------- |
| 0 | 5 | 6         |
| 1 | 2 | 4         |
| 2 | 2 | 7         |
| 3 | 2 | 29        |


### 編譯與執行指令

```bash
# 編譯
$ g++ ackermann.cpp -o ackermann.exe

# 執行
ackermann.exe
```

### 結論

1.遞迴深度極大：Ackermann 函數的遞迴層級成長非常快速，稍大的參數即會導致堆疊溢位或執行時間過長。

2.演算法特性：該函數無法用一般的迴圈簡單地轉換成閉合形式，其定義本質上需要透過遞迴或堆疊模擬實現。

3.非遞迴模擬的重要性：利用堆疊（stack）模擬呼叫過程，可以避免系統遞迴造成的堆疊溢位問題，並更清楚了解遞迴的執行邏輯。

4.效能觀察：從執行結果可知，Ackermann 函數即使輸入很小的整數值，也會產生極大的輸出結果，顯示其在理論計算中具代表性的「超快速成長」特性。

## 申論及開發報告

### 1. **Ackermann function程式邏輯簡單直觀**

(1) 遞迴版本設計

	根據 Ackermann 函數的數學定義：
   <img width="709" height="176" alt="image" src="https://github.com/user-attachments/assets/11ee3a9b-0b68-4beb-8e40-41466a5d5a3b" />

遞迴版本可直接以 C++ 函式實現，每次呼叫都會根據條件分支進入下一層遞迴，直到 m == 0 為止。

(2) 非遞迴版本設計

	由於 Ackermann 函數的遞迴層數可能非常深，容易導致「stack overflow」錯誤，因此改用手動堆疊來模擬遞迴過程。
以 std::stack 儲存變數 m 的狀態，每當函式遞迴呼叫時，改以推入堆疊、更新 n 值的方式實現。
此方式避免了系統遞迴的限制，並能清楚觀察遞迴呼叫的邏輯流程。

### 2. **易於理解與實現**  

	本次 Ackermann 函數的實作雖然數學定義看似複雜，但透過清楚的條件判斷與遞迴關係，其實非常容易轉換為程式邏輯。

1.結構明確：
	Ackermann 函數僅依照三個簡單的條件式（m=0、n=0、其他情況）即可完整定義，程式的邏輯分支清晰明確，也能快速掌握遞迴概念。

2.程式簡潔：
	遞迴版本的 C++ 程式僅需數行即可完成，充分展現遞迴函式的結構性與可讀性；非遞迴版本則利用堆疊（stack）模擬呼叫過程，讓整體執行流程更具可視化與可理解性。

3.實現容易、測試方便：
	只需輸入兩個整數 m 與 n，即可測試結果。

### 3. **Ackermann function的語意清楚**

   Ackermann 函數是一個 非原始遞迴（non–primitive recursive）函數，能夠產生極高速增長的數值。
本次實作的目的在於：

1.深入理解遞迴呼叫（recursive call）的運作方式。

2.嘗試以堆疊結構（stack）模擬遞迴，以實現非遞迴版本。

3.比較兩種演算法在執行效能與可行性上的差異。

透過此函數，我們可以更清楚地看到遞迴演算法的威力與限制，並學會如何在不使用系統遞迴的情況下完成等價運算。

-------------------------------------------

作業二 *powerset*

## 解題說明

本題要求實作冪集。

### 解題策略

	1.是否選擇a
	2.是否選擇b
	3.是否選擇c
	4.最後印出結果

## 程式實作

以下為主要程式碼：

```cpp

// 遞迴生成冪集
void powerset(vector<char>& set, vector<char>& subset, int index) {
    if (index == set.size()) {   // 遞迴到底：輸出子集合
        cout << "{ ";
        for (char c : subset) cout << c << " ";
        cout << "}" << endl;
        return;
    }
    powerset(set, subset, index + 1);       // 不選當前元素
    subset.push_back(set[index]);           // 選當前元素
    powerset(set, subset, index + 1);
    subset.pop_back();                      // 回溯
}

```

## 效能分析

1. 時間複雜度：程式的時間複雜度為 **O(n2^n)**。
2. 空間複雜度：空間複雜度為 **O(n)**。

## 測試與驗證

### 測試案例

| 測試案例 | 輸入集合 (S)       | 期望輸出冪集                                                                              |
| ---- | -------------- | ----------------------------------------------------------------------------------- |
| 1    | {a}          | { {}, {a} }                                                                       |
| 2    | {a, b}       | { {}, {a}, {b}, {a, b} }                                                          |
| 3    | {a, b, c}    | { {}, {a}, {b}, {c}, {a,b}, {a,c}, {b,c}, {a,b,c} }                               |

### 編譯與執行指令

```bash
$ g++ powerset.cpp -o powerset

powerset.exe

```

### 結論

1. 問題性質:
	
	本題是要列舉一個集合的 冪集 (Powerset)。
	
	若集合大小為𝑛，則必須產生2^n個子集合。 

2. 測試案例:
	
	驗證公式：輸出數量必須等於2^𝑛。
	
	已提供多組測試（空集合、單元素、兩元素、三元素等）。 

3. 程式碼中利用 push_back + pop_back 保證正確回溯，不影響其他分支。

## 申論及開發報告

本題要求設計一個程式，能輸入一個集合並輸出其所有子集合。

### 1. **程式邏輯簡單直觀**  

   *選取該元素*
   
   *不選取該元素*
   
	因此整個解空間為一棵深度為𝑛的二元遞迴樹，節點數為 2^(𝑛+1) −1。

### 2. **易於理解與實現**  

採用 遞迴 + 回溯法 (recursion + backtracking)：
	
	遞迴參數包含：集合、目前子集合、當前索引。
	
	每層分為「選取」與「不選取」兩種情況。
	
	遞迴到底 (index == n) 時輸出子集合。
	
	使用回溯 (push_back / pop_back) 保持正確狀態。

### 3. **遞迴的語意清楚**

1.冪集列舉問題本質上具有 指數級複雜度。

2.遞迴回溯法程式碼簡潔直觀。

3.在 n 較大時，應避免完整列舉，改採數學公式、條件篩選或統計方法處理。
