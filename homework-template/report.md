# 41343108

作業一 Ackermann 函數

## 解題說明

實作 Ackermann 函數 A(m, n)。

尋找遞迴規則:

	n+1            ,if m=0
	A(m-1,1)       ,if n=0
	A(m-1,A(m,n-1)),otherwise

### 解題策略

1.寫出遞迴版本的 Ackermann 函數

   Ackermann 函數的定義本身就是遞迴形式，因此最直接的做法是「直接照數學公式轉換成程式」。

2.再寫出非遞迴（使用 stack 模擬遞迴）的版本

   用「自己建立的堆疊（stack）」模擬「系統遞迴呼叫堆疊」。
   在每次函數呼叫時，我們將 m 的值推入堆疊。
   然後根據條件（m 與 n 的值）逐步更新變數 n，直到堆疊清空。

## 程式實作

以下為主要程式碼: 

### 遞迴版本（Recursive Version)

```cpp

    if (m == 0) {
        // 當 m = 0 時，回傳 n + 1
        return n + 1;
    } 
    else if (n == 0) {
        // 當 n = 0 時，呼叫 A(m - 1, 1)
        return Ackermann(m - 1, 1);
    } 
    else {
        // 一般情況，呼叫 A(m - 1, A(m, n - 1))
        // 先計算內層 A(m, n - 1)，再把結果代入 A(m - 1, ...)
        return Ackermann(m - 1, Ackermann(m, n - 1));
    }
```

### 非遞迴版本（Non-Recursive Version）

```cpp

    while (!s.empty()) {
        m = s.top();  // 取出堆疊最上層的 m 值
        s.pop();      // 將該元素移除（模擬函數返回）

        if (m == 0) {
            // A(0, n) = n + 1
            n = n + 1;
        } 
        else if (n == 0) {
            // A(m, 0) = A(m - 1, 1)
            s.push(m - 1);  // 把 (m-1) 壓回堆疊
            n = 1;          // n 改為 1，下一輪會處理這個情況
        } 
        else {
            // A(m, n) = A(m - 1, A(m, n - 1))
            // 因為要先計算 A(m, n - 1)，所以暫時保存當前 m 值
            s.push(m - 1);  // 將 m-1 推入堆疊（等待 A(m, n-1) 結果）
            s.push(m);      // 將原 m 再次推入堆疊，模擬下一層呼叫
            n = n - 1;      // 將 n 減 1，準備下一輪計算 A(m, n-1)
        }
    }

```

## 效能分析

1. 時間複雜度：Ackermann 函數的時間複雜度極高，
因為在遞迴展開過程中會產生大量的巢狀呼叫。

雖然沒有封閉式公式，但可概略歸納如下：

	A(0, n)：O(1)
	A(1, n)：O(n)
	A(2, n)：O(n)
	A(3, n)：O(2ⁿ)（指數級）
	A(4, n)：超指數級（成長快於任何多項式或指數函數）

當 m 值每增加 1，函數的「運算層級」就會提升一個維度。

2. 空間複雜度：Ackermann 函數的空間複雜度主要取決於遞迴深度。

遞迴版本：
	每一層呼叫都會佔用新的函數堆疊空間，因此空間複雜度為
	O(遞迴深度)，通常非常大。
	例如 A(3, 6) 可能已產生上萬層呼叫。

非遞迴版本：
	使用 stack 模擬遞迴，因此記憶體需求與遞迴深度相同。
	只是由程式控制堆疊，而非系統呼叫堆疊。

## 測試與驗證

### 測試案例

| m | n | 結果 A(m,n) |
| - | - | --------- |
| 0 | 5 | 6         |
| 1 | 2 | 4         |
| 2 | 2 | 7         |
| 3 | 2 | 29        |


### 編譯與執行指令

```bash
# 編譯
g++ ackermann.cpp -o ackermann.exe

# 執行
ackermann.exe
```

### 結論

1.遞迴深度極大：Ackermann 函數的遞迴層級成長非常快速，稍大的參數即會導致堆疊溢位或執行時間過長。

2.演算法特性：該函數無法用一般的迴圈簡單地轉換成閉合形式，其定義本質上需要透過遞迴或堆疊模擬實現。

3.非遞迴模擬的重要性：利用堆疊（stack）模擬呼叫過程，可以避免系統遞迴造成的堆疊溢位問題，並更清楚了解遞迴的執行邏輯。

4.效能觀察：從執行結果可知，Ackermann 函數即使輸入很小的整數值，也會產生極大的輸出結果，顯示其在理論計算中具代表性的「超快速成長」特性。

## 申論及開發報告

1. **程式邏輯簡單直觀**

(1) 遞迴版本設計

根據 Ackermann 函數的數學定義：
   <img width="709" height="176" alt="image" src="https://github.com/user-attachments/assets/11ee3a9b-0b68-4beb-8e40-41466a5d5a3b" />
   遞迴版本可直接以 C++ 函式實現，每次呼叫都會根據條件分支進入下一層遞迴，直到 m == 0 為止。

(2) 非遞迴版本設計

由於 Ackermann 函數的遞迴層數可能非常深，容易導致「stack overflow」錯誤，因此改用手動堆疊來模擬遞迴過程。
以 std::stack 儲存變數 m 的狀態，每當函式遞迴呼叫時，改以推入堆疊、更新 n 值的方式實現。
此方式避免了系統遞迴的限制，並能清楚觀察遞迴呼叫的邏輯流程。

2. **易於理解與實現**  
   遞迴的程式碼更接近數學公式的表示方式，特別適合新手學習遞迴的基本概念。  
   以本程式為例：  

   ```cpp
   int sigma(int n) {
       if (n < 0)
           throw "n < 0";
       else if (n <= 1)
           return n;
       return n + sigma(n - 1);
   }
   ```

3. **遞迴的語意清楚**  
   在程式中，每次遞迴呼叫都代表一個「子問題的解」，而最終遞迴的返回結果會逐層相加，完成整體問題的求解。  
   這種設計簡化了邏輯，不需要額外變數來維護中間狀態。

透過遞迴實作 Sigma 計算，程式邏輯簡單且易於理解，特別適合展示遞迴的核心思想。然而，遞迴會因堆疊深度受到限制，當 $n$ 值過大時，應考慮使用迭代版本來避免 Stack Overflow 問題。
