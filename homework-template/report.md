# 41343108

作業一 *Ackermann函數*

## 解題說明

實作 Ackermann 函數 A(m, n)。

尋找遞迴規則：

	n+1            ,if m=0
	A(m-1,1)       ,if n=0
	A(m-1,A(m,n-1)),otherwise

### 解題策略

1.寫出遞迴版本的 Ackermann 函數

   Ackermann 函數的定義本身就是遞迴形式，因此最直接的做法是「直接照數學公式轉換成程式」。

2.再寫出非遞迴（使用 stack 模擬遞迴）的版本

   用「自己建立的堆疊（stack）」模擬「系統遞迴呼叫堆疊」。
   在每次函數呼叫時，我們將 m 的值推入堆疊。
   然後根據條件（m 與 n 的值）逐步更新變數 n，直到堆疊清空。

## 程式實作

以下為主要程式碼: 

### 遞迴版本（Recursive Version)

```cpp

    if (m == 0) {
        // 當 m = 0 時，回傳 n + 1
        return n + 1;
    } 
    else if (n == 0) {
        // 當 n = 0 時，呼叫 A(m - 1, 1)
        return Ackermann(m - 1, 1);
    } 
    else {
        // 一般情況，呼叫 A(m - 1, A(m, n - 1))
        // 先計算內層 A(m, n - 1)，再把結果代入 A(m - 1, ...)
        return Ackermann(m - 1, Ackermann(m, n - 1));
    }
```

### 非遞迴版本（Non-Recursive Version）

```cpp

    while (!s.empty()) {
        m = s.top();  // 取出堆疊最上層的 m 值
        s.pop();      // 將該元素移除（模擬函數返回）

        if (m == 0) {
            // A(0, n) = n + 1
            n = n + 1;
        } 
        else if (n == 0) {
            // A(m, 0) = A(m - 1, 1)
            s.push(m - 1);  // 把 (m-1) 壓回堆疊
            n = 1;          // n 改為 1，下一輪會處理這個情況
        } 
        else {
            // A(m, n) = A(m - 1, A(m, n - 1))
            // 因為要先計算 A(m, n - 1)，所以暫時保存當前 m 值
            s.push(m - 1);  // 將 m-1 推入堆疊（等待 A(m, n-1) 結果）
            s.push(m);      // 將原 m 再次推入堆疊，模擬下一層呼叫
            n = n - 1;      // 將 n 減 1，準備下一輪計算 A(m, n-1)
        }
    }

```

## 效能分析

1. 時間複雜度：Ackermann 函數的時間複雜度極高，
因為在遞迴展開過程中會產生大量的巢狀呼叫。

雖然沒有封閉式公式，但可概略歸納如下：

	A(0, n)：O(1)
	A(1, n)：O(n)
	A(2, n)：O(n)
	A(3, n)：O(2ⁿ)（指數級）
	A(4, n)：超指數級（成長快於任何多項式或指數函數）

當 m 值每增加 1，函數的「運算層級」就會提升一個維度。


2. 空間複雜度：Ackermann 函數的空間複雜度主要取決於遞迴深度。

遞迴版本：
	每一層呼叫都會佔用新的函數堆疊空間，因此空間複雜度為
	O(遞迴深度)，通常非常大。

非遞迴版本：
	使用 stack 模擬遞迴，因此記憶體需求與遞迴深度相同。
	只是由程式控制堆疊，而非系統呼叫堆疊。

## 測試與驗證

### 測試案例

| m | n | 結果 A(m,n) |
| - | - | --------- |
| 0 | 5 | 6         |
| 1 | 2 | 4         |
| 2 | 2 | 7         |
| 3 | 2 | 29        |


### 編譯與執行指令

```bash
# 編譯
$ g++ ackermann.cpp -o ackermann.exe

# 執行
ackermann.exe
```

### 結論

1.遞迴深度極大：Ackermann 函數的遞迴層級成長非常快速，稍大的參數即會導致堆疊溢位或執行時間過長。

2.演算法特性：該函數無法用一般的迴圈簡單地轉換成閉合形式，其定義本質上需要透過遞迴或堆疊模擬實現。

3.非遞迴模擬的重要性：利用堆疊（stack）模擬呼叫過程，可以避免系統遞迴造成的堆疊溢位問題，並更清楚了解遞迴的執行邏輯。

4.效能觀察：從執行結果可知，Ackermann 函數即使輸入很小的整數值，也會產生極大的輸出結果，顯示其在理論計算中具代表性的「超快速成長」特性。

## 申論及開發報告

### 1. **Ackermann function程式邏輯簡單直觀**

(1) 遞迴版本設計

	根據 Ackermann 函數的數學定義：
   <img width="709" height="176" alt="image" src="https://github.com/user-attachments/assets/11ee3a9b-0b68-4beb-8e40-41466a5d5a3b" />

遞迴版本可直接以 C++ 函式實現，每次呼叫都會根據條件分支進入下一層遞迴，直到 m == 0 為止。

(2) 非遞迴版本設計

	由於 Ackermann 函數的遞迴層數可能非常深，容易導致「stack overflow」錯誤，因此改用手動堆疊來模擬遞迴過程。
以 std::stack 儲存變數 m 的狀態，每當函式遞迴呼叫時，改以推入堆疊、更新 n 值的方式實現。
此方式避免了系統遞迴的限制，並能清楚觀察遞迴呼叫的邏輯流程。

### 2. **易於理解與實現**  

	本次 Ackermann 函數的實作雖然數學定義看似複雜，但透過清楚的條件判斷與遞迴關係，其實非常容易轉換為程式邏輯。

1.結構明確：
	Ackermann 函數僅依照三個簡單的條件式（m=0、n=0、其他情況）即可完整定義，程式的邏輯分支清晰明確，也能快速掌握遞迴概念。

2.程式簡潔：
	遞迴版本的 C++ 程式僅需數行即可完成，充分展現遞迴函式的結構性與可讀性；非遞迴版本則利用堆疊（stack）模擬呼叫過程，讓整體執行流程更具可視化與可理解性。

3.實現容易、測試方便：
	只需輸入兩個整數 m 與 n，即可測試結果。

### 3. **Ackermann function的語意清楚**

   Ackermann 函數是一個 非原始遞迴（non–primitive recursive）函數，能夠產生極高速增長的數值。
本次實作的目的在於：

1.深入理解遞迴呼叫（recursive call）的運作方式。

2.嘗試以堆疊結構（stack）模擬遞迴，以實現非遞迴版本。

3.比較兩種演算法在執行效能與可行性上的差異。

透過此函數，我們可以更清楚地看到遞迴演算法的威力與限制，並學會如何在不使用系統遞迴的情況下完成等價運算。

-------------------------------------------

作業二 *powerset*

## 解題說明

本題要求實作冪集。

### 解題策略

	1.是否選擇a
	2.是否選擇b
	3.是否選擇c
	4.最後印出結果

## 程式實作

以下為主要程式碼：

```cpp

// 遞迴生成冪集
void powerset(vector<char>& set, vector<char>& subset, int index) {
    if (index == set.size()) {   // 遞迴到底：輸出子集合
        cout << "{ ";
        for (char c : subset) cout << c << " ";
        cout << "}" << endl;
        return;
    }
    powerset(set, subset, index + 1);       // 不選當前元素
    subset.push_back(set[index]);           // 選當前元素
    powerset(set, subset, index + 1);
    subset.pop_back();                      // 回溯
}

```

## 效能分析

1. 時間複雜度：程式的時間複雜度為 Θ(n2n)。
2. 空間複雜度：空間複雜度為 $O(100\times \log n + \pi)$。

## 測試與驗證

### 測試案例

| 測試案例 | 輸入參數 $n$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $n = 0$      | 0        | 0        |
| 測試二   | $n = 1$      | 1        | 1        |
| 測試三   | $n = 3$      | 6        | 6        |
| 測試四   | $n = 5$      | 15       | 15       |
| 測試五   | $n = -1$     | 異常拋出 | 異常拋出 |

### 編譯與執行指令

```shell
$ g++ -std=c++17 -o sigma sigma.cpp
$ ./sigma
6
```

### 結論

1. 程式能正確計算 $n$ 到 $1$ 的連加總和。  
2. 在 $n < 0$ 的情況下，程式會成功拋出異常，符合設計預期。  
3. 測試案例涵蓋了多種邊界情況（$n = 0$、$n = 1$、$n > 1$、$n < 0$），驗證程式的正確性。

## 申論及開發報告

### 選擇遞迴的原因

在本程式中，使用遞迴來計算連加總和的主要原因如下：

1. **程式邏輯簡單直觀**  
   遞迴的寫法能夠清楚表達「將問題拆解為更小的子問題」的核心概念。  
   例如，計算 $\Sigma(n)$ 的過程可分解為：  

   $$
   \Sigma(n) = n + \Sigma(n-1)
   $$

   當 $n$ 等於 1 或 0 時，直接返回結果，結束遞迴。

2. **易於理解與實現**  
   遞迴的程式碼更接近數學公式的表示方式，特別適合新手學習遞迴的基本概念。  
   以本程式為例：  

   ```cpp
   int sigma(int n) {
       if (n < 0)
           throw "n < 0";
       else if (n <= 1)
           return n;
       return n + sigma(n - 1);
   }
   ```

3. **遞迴的語意清楚**  
   在程式中，每次遞迴呼叫都代表一個「子問題的解」，而最終遞迴的返回結果會逐層相加，完成整體問題的求解。  
   這種設計簡化了邏輯，不需要額外變數來維護中間狀態。

透過遞迴實作 Sigma 計算，程式邏輯簡單且易於理解，特別適合展示
